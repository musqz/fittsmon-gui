#!/usr/bin/env python3
"""
fittsmon Configuration GUI - Simple Edition
"""

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Gdk
import subprocess
import os
import time
from pathlib import Path

class ConfigParser:
    """Custom config parser that preserves case"""
    
    def __init__(self):
        self.data = {}
    
    def read(self, filepath):
        """Read config file preserving case"""
        self.data = {}
        if not filepath.exists():
            return
        
        current_section = None
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                
                if not line or line.startswith('#'):
                    continue
                
                if line.startswith('[') and line.endswith(']'):
                    current_section = line[1:-1]
                    self.data[current_section] = {}
                    continue
                
                if '=' in line and current_section:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    self.data[current_section][key] = value
    
    def write(self, filepath, zones, events, monitors):
        """
        Write config file preserving case
        Writes ALL sections for ALL zones with ALL events (even if empty)
        Order: Primary first, then each secondary monitor
        """
        with open(filepath, 'w') as f:
            f.write("# fittsmon Configuration\n")
            f.write("# Generated by fittsmon GUI\n\n")
            
            # Sort monitors: primary first, then others
            primary_mon = None
            secondary_mons = []
            
            for mon in monitors:
                if mon['primary']:
                    primary_mon = mon
                else:
                    secondary_mons.append(mon)
            
            sorted_monitors = []
            if primary_mon:
                sorted_monitors.append(primary_mon)
            sorted_monitors.extend(secondary_mons)
            
            # Write all monitors in order
            for mon in sorted_monitors:
                mon_name = mon['name']
                
                # Write all zones for this monitor
                for zone in zones:
                    # Create section name
                    if mon['primary']:
                        section_name = zone
                    else:
                        section_name = f"{mon_name}-{zone}"
                    
                    f.write(f"[{section_name}]\n")
                    
                    # Write ALL events (even if empty)
                    for event in events:
                        value = self.data.get(section_name, {}).get(event, "")
                        f.write(f"{event}={value}\n")
                    
                    f.write("\n")
    
    def has_section(self, section):
        return section in self.data
    
    def add_section(self, section):
        if section not in self.data:
            self.data[section] = {}
    
    def get(self, section, option, fallback=""):
        try:
            return self.data[section][option]
        except KeyError:
            return fallback
    
    def set(self, section, option, value):
        if section not in self.data:
            self.data[section] = {}
        self.data[section][option] = value
    
    def remove_option(self, section, option):
        if section in self.data and option in self.data[section]:
            del self.data[section][option]

class FittsmonGUI:
    # Only wheel events conflict
    CONFLICT_PAIRS = {
        'WheelUp': 'WheelUpOnce',
        'WheelUpOnce': 'WheelUp',
        'WheelDown': 'WheelDownOnce',
        'WheelDownOnce': 'WheelDown'
    }
    
    def __init__(self):
        self.config_dir = Path.home() / ".config/fittsmon"
        self.config_file = self.config_dir / "fittsmonrc"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.monitors = []
        self.config = ConfigParser()
        
        # 8 zones in correct order
        self.zones = [
            "TopLeft",
            "TopCenter", 
            "TopRight",
            "Left",
            "Right",
            "BottomLeft",
            "BottomCenter",
            "BottomRight"
        ]
        
        # 9 events
        self.events = [
            "WheelUp",
            "WheelDown",
            "WheelUpOnce",
            "WheelDownOnce",
            "LeftButton",
            "RightButton",
            "MiddleButton",
            "Enter",
            "Leave"
        ]
        
        self.detect_monitors()
        self.load_config()
        self.setup_gui()
    
    def detect_monitors(self):
        """Detect connected monitors using xrandr"""
        try:
            result = subprocess.run(
                ["xrandr", "--query"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            for line in result.stdout.split('\n'):
                if ' connected' in line:
                    parts = line.split()
                    if len(parts) > 0:
                        monitor_name = parts[0]
                        is_primary = 'primary' in line
                        self.monitors.append({
                            'name': monitor_name,
                            'primary': is_primary
                        })
                        print(f"[DETECT] Monitor: {monitor_name} {'[PRIMARY]' if is_primary else ''}")
        except Exception as e:
            print(f"[ERROR] Monitor detection failed: {e}")
            self.monitors = [{'name': 'default', 'primary': True}]
    
    def load_config(self):
        """Load configuration from fittsmonrc"""
        self.config = ConfigParser()
        if self.config_file.exists():
            print(f"[CONFIG] Loading: {self.config_file}")
            self.config.read(self.config_file)
        else:
            print(f"[CONFIG] File not found - will create on save")
    
    def save_config(self):
        """Save configuration to fittsmonrc"""
        try:
            # Pass zones, events, and monitors to write method
            self.config.write(self.config_file, self.zones, self.events, self.monitors)
            print(f"[CONFIG] Saved: {self.config_file}")
            self.set_status("‚úì Saved!", error=False)
            return True
        except Exception as e:
            print(f"[ERROR] Failed to save config: {e}")
            self.set_status(f"‚úó Error: {e}", error=True)
            return False
    
    def get_section_name(self, monitor, zone):
        """Get config section name for monitor and zone"""
        if monitor == self.monitors[0]['name'] and self.monitors[0]['primary']:
            return zone
        else:
            return f"{monitor}-{zone}"
    
    def get_command(self, monitor, zone, event):
        """Get command for a specific monitor, zone, and event"""
        section = self.get_section_name(monitor, zone)
        return self.config.get(section, event, fallback="")
    
    def set_command(self, monitor, zone, event, command):
        """Set command for a specific monitor, zone, and event"""
        section = self.get_section_name(monitor, zone)
        
        if not self.config.has_section(section):
            self.config.add_section(section)
        
        # Auto-clear conflicting wheel events
        if command and event in self.CONFLICT_PAIRS:
            conflict_event = self.CONFLICT_PAIRS[event]
            conflict_cmd = self.config.get(section, conflict_event, fallback="")
            if conflict_cmd:
                print(f"[CONFIG] Auto-clearing: {section}.{conflict_event}")
                self.config.remove_option(section, conflict_event)
        
        # Set the command
        self.config.set(section, event, command)
        print(f"[CONFIG] Set {section}.{event} = '{command}'")
    
    def check_conflict(self, event):
        """Check if there's a wheel event conflict"""
        if event not in self.CONFLICT_PAIRS:
            return None
        
        conflict_event = self.CONFLICT_PAIRS[event]
        current_cmd = self.get_command(self.current_monitor, self.current_zone, event)
        conflict_cmd = self.get_command(self.current_monitor, self.current_zone, conflict_event)
        
        if current_cmd == "" and conflict_cmd:
            return {
                'event': event,
                'conflict_event': conflict_event,
                'conflict_value': conflict_cmd
            }
        
        return None
    
    def kill_fittsmon(self):
        """Kill fittsmon process"""
        try:
            subprocess.run(
                ["killall", "fittsmon"],
                capture_output=True,
                text=True,
                timeout=3
            )
            print("[DAEMON] Killed fittsmon")
            time.sleep(0.5)
            return True
        except:
            return False
    
    def start_fittsmon(self):
        """Start fittsmon daemon with all detected monitors"""
        try:
            cmd = ["fittsmon", "--monitor"] + [m['name'] for m in self.monitors]
            print(f"[DAEMON] Starting: {' '.join(cmd)}")
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                preexec_fn=os.setsid if hasattr(os, 'setsid') else None
            )
            
            time.sleep(1)
            
            if process.poll() is None:
                print(f"[DAEMON] Started successfully (PID: {process.pid})")
                return True
            else:
                return False
        except Exception as e:
            print(f"[ERROR] Failed to start fittsmon: {e}")
            return False
    
    def restart_fittsmon(self):
        """Restart fittsmon daemon"""
        print("[DAEMON] Restarting fittsmon...")
        self.kill_fittsmon()
        time.sleep(1)
        return self.start_fittsmon()
    
    def setup_gui(self):
        """Setup GTK GUI"""
        self.window = Gtk.Window(type=Gtk.WindowType.TOPLEVEL)
        self.window.set_title("fittsmon")
        self.window.set_default_size(850, 700)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", Gtk.main_quit)
        # Set application icon (try theme icon name, fallback to bundled svg)
        try:
            # Prefer the standard themed icon `input-mouse`
            icon_theme = Gtk.IconTheme.get_default()
            if icon_theme and icon_theme.has_icon('input-mouse'):
                try:
                    self.window.set_icon_name('input-mouse')
                    Gtk.Window.set_default_icon_name('input-mouse')
                except Exception:
                    pass
            else:
                # Fallback to local icon shipped with the repo (if present)
                local_icon = os.path.join(os.path.dirname(__file__), 'icons', 'scalable', 'apps', 'fittsmon-gui.svg')
                if os.path.exists(local_icon):
                    try:
                        self.window.set_icon_from_file(local_icon)
                    except Exception:
                        pass
        except Exception:
            pass
        
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        main_box.set_margin_top(15)
        main_box.set_margin_bottom(15)
        main_box.set_margin_start(15)
        main_box.set_margin_end(15)
        self.window.add(main_box)
        
        # Title
        title = Gtk.Label()
        title.set_markup("<big><b>fittsmon action manager</b></big>\n<small>Screen Corner Hotspots</small>")
        main_box.pack_start(title, False, False, 0)
        
        # Status
        self.status_label = Gtk.Label()
        self.status_label.set_markup("<small>Ready</small>")
        self.status_label.set_line_wrap(True)
        main_box.pack_start(self.status_label, False, False, 0)
        
        main_box.pack_start(Gtk.Separator(), False, False, 0)
        
        # Monitor selection
        mon_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        mon_box.pack_start(Gtk.Label(label="Monitor:"), False, False, 0)
        self.monitor_combo = Gtk.ComboBoxText()
        for monitor in self.monitors:
            label = f"{monitor['name']} {'[PRIMARY]' if monitor['primary'] else ''}"
            self.monitor_combo.append_text(label)
        self.monitor_combo.set_active(0)
        self.monitor_combo.connect("changed", self.on_monitor_changed)
        self.current_monitor = self.monitors[0]['name']
        mon_box.pack_start(self.monitor_combo, True, True, 0)
        main_box.pack_start(mon_box, False, False, 0)
        
        # Zone selection
        zone_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        zone_box.pack_start(Gtk.Label(label="Zone:"), False, False, 0)
        self.zone_combo = Gtk.ComboBoxText()
        for zone in self.zones:
            self.zone_combo.append_text(zone)
        self.zone_combo.set_active(0)
        self.zone_combo.connect("changed", self.on_zone_changed)
        self.current_zone = self.zones[0]
        zone_box.pack_start(self.zone_combo, True, True, 0)
        main_box.pack_start(zone_box, False, False, 0)

        # Zone visual grid (3x3) - clickable squares mapped to zones
        self.zone_buttons = {}
        grid = Gtk.Grid()
        grid.set_row_spacing(6)
        grid.set_column_spacing(6)

        # mapping positions to zone names (center is unused)
        pos_map = {
            (0,0): 'TopLeft', (1,0): 'TopCenter', (2,0): 'TopRight',
            (0,1): 'Left',    (1,1): None,         (2,1): 'Right',
            (0,2): 'BottomLeft',(1,2): 'BottomCenter',(2,2): 'BottomRight'
        }

        for (x,y), zone in pos_map.items():
            if zone is None:
                placeholder = Gtk.Box()
                placeholder.set_size_request(44,44)
                grid.attach(placeholder, x, y, 1, 1)
                continue

            btn = Gtk.Button()
            btn.set_size_request(44,44)
            btn.get_style_context().add_class('zone-button')
            btn.set_tooltip_text(zone)
            btn.connect('clicked', lambda w, z=zone: self.on_zone_button_clicked(z))
            grid.attach(btn, x, y, 1, 1)
            self.zone_buttons[zone] = btn

        # Center the hotspot grid visually
        grid_container = Gtk.Box()
        grid_container.set_halign(Gtk.Align.CENTER)
        grid_container.set_valign(Gtk.Align.CENTER)
        grid_container.pack_start(grid, False, False, 0)
        main_box.pack_start(grid_container, False, False, 0)

        # CSS for zone colors
        try:
            css = b"""
            .zone-button {
              border-radius: 4px;
              background-color: #c0c0c0;
              border: 1px solid #8f8f8f;
            }
            .zone-button.not-used {
              background-color: #d0d0d0;
            }
            .zone-button.not-selected {
              background-color: #d6eef9;
            }
            .zone-button.selected {
              background-color: #1976D2;
              color: #ffffff;
            }
            """
            provider = Gtk.CssProvider()
            provider.load_from_data(css)
            screen = Gdk.Screen.get_default()
            if screen:
                Gtk.StyleContext.add_provider_for_screen(screen, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
        except Exception:
            pass

        # Event selection
        event_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        event_box.pack_start(Gtk.Label(label="Event:"), False, False, 0)
        self.event_combo = Gtk.ComboBoxText()
        for event in self.events:
            self.event_combo.append_text(event)
        self.event_combo.set_active(0)
        self.event_combo.connect("changed", self.on_event_changed)
        self.current_event = self.events[0]
        event_box.pack_start(self.event_combo, True, True, 0)
        main_box.pack_start(event_box, False, False, 0)
        
        # Event info
        self.info_label = Gtk.Label()
        self.info_label.set_line_wrap(True)
        self.info_label.set_halign(Gtk.Align.START)
        main_box.pack_start(self.info_label, False, False, 0)
        
        # Command input
        cmd_label = Gtk.Label(label="Command:")
        cmd_label.set_halign(Gtk.Align.START)
        main_box.pack_start(cmd_label, False, False, 0)
        self.command_entry = Gtk.Entry()
        self.command_entry.set_placeholder_text("e.g., amixer -D pulse set Master 5%+")
        self.command_entry.connect("changed", self.on_command_changed)
        main_box.pack_start(self.command_entry, False, False, 0)
        
        # Warning box
        self.warning_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.warning_label = Gtk.Label()
        self.warning_label.set_line_wrap(True)
        self.warning_label.set_halign(Gtk.Align.START)
        self.warning_box.pack_start(self.warning_label, False, False, 0)
        
        self.auto_clear_btn = Gtk.Button(label="‚úì Clear Conflict")
        self.auto_clear_btn.connect("clicked", self.on_auto_clear_clicked)
        self.warning_box.pack_start(self.auto_clear_btn, False, False, 0)
        
        main_box.pack_start(self.warning_box, False, False, 0)
        
        self.update_command_display()
        # Ensure visual buttons reflect current state
        self.update_zone_buttons()
        
        # Action buttons
        action_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        test_btn = Gtk.Button(label="üß™ Test")
        test_btn.connect("clicked", self.on_test_clicked)
        action_box.pack_start(test_btn, True, True, 0)
        
        edit_btn = Gtk.Button(label="‚úèÔ∏è  Edit File")
        edit_btn.connect("clicked", self.on_edit_clicked)
        action_box.pack_start(edit_btn, True, True, 0)
        
        main_box.pack_start(action_box, False, False, 0)
        
        # Save & Restart button
        sr_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        save_btn = Gtk.Button(label="üíæ Save")
        save_btn.set_size_request(-1, 40)
        save_btn.get_style_context().add_class("suggested-action")
        save_btn.connect("clicked", self.on_save_clicked)
        sr_box.pack_start(save_btn, True, True, 0)
        
        restart_btn = Gtk.Button(label="‚ü≥ Restart")
        restart_btn.set_size_request(-1, 40)
        restart_btn.get_style_context().add_class("destructive-action")
        restart_btn.connect("clicked", self.on_restart_clicked)
        sr_box.pack_start(restart_btn, True, True, 0)
        
        main_box.pack_start(sr_box, False, False, 0)
        
        self.window.show_all()
    
    def get_event_info(self, event):
        """Get simple event description"""
        info_map = {
            'WheelUp': "Scroll wheel UP",
            'WheelDown': "Scroll wheel DOWN",
            'WheelUpOnce': "Scroll UP once per 2 seconds",
            'WheelDownOnce': "Scroll DOWN once per 2 seconds",
            'LeftButton': "Left mouse button",
            'RightButton': "Right mouse button",
            'MiddleButton': "Middle mouse button",
            'Enter': "Mouse enters corner",
            'Leave': "Mouse leaves corner"
        }
        return info_map.get(event, "")
    
    def update_command_display(self):
        """Update command display"""
        cmd = self.get_command(self.current_monitor, self.current_zone, self.current_event)
        
        self.command_entry.handler_block_by_func(self.on_command_changed)
        self.command_entry.set_text(cmd)
        self.command_entry.handler_unblock_by_func(self.on_command_changed)
        
        self.info_label.set_markup(f"<small>{self.get_event_info(self.current_event)}</small>")
        
        self.show_conflict_warning()
        # Update zone buttons to reflect which zones have commands and which is active
        try:
            self.update_zone_buttons()
        except Exception:
            pass
    
    def show_conflict_warning(self):
        """Show warning only for wheel conflicts"""
        conflict = self.check_conflict(self.current_event)
        
        if conflict:
            msg = (
                f"‚ö†Ô∏è  <b>{conflict['conflict_event']}</b> already set!\n"
                f"Can't use both <b>{conflict['event']}</b> and <b>{conflict['conflict_event']}</b>"
            )
            self.warning_label.set_markup(msg)
            self.warning_box.show_all()
        else:
            self.warning_box.hide()
    
    def on_monitor_changed(self, widget):
        idx = self.monitor_combo.get_active()
        if idx >= 0:
            self.current_monitor = self.monitors[idx]['name']
            self.update_command_display()
    
    def on_zone_changed(self, widget):
        idx = self.zone_combo.get_active()
        if idx >= 0:
            self.current_zone = self.zones[idx]
            self.update_command_display()

    def on_zone_button_clicked(self, zone):
        """Handle clicking a visual zone button: select the zone."""
        try:
            idx = self.zones.index(zone)
            self.zone_combo.set_active(idx)
            # on_zone_changed will call update_command_display
        except ValueError:
            pass

    def update_zone_buttons(self):
        """Refresh visual state of zone buttons.

        States:
        - not-used: no command configured (grey)
        - not-selected: has command but not current (light blue)
        - selected: current zone (highlight)
        """
        for zone, btn in self.zone_buttons.items():
            # clear state classes
            sc = btn.get_style_context()
            for cls in ('selected', 'not-selected', 'not-used'):
                try:
                    sc.remove_class(cls)
                except Exception:
                    pass

            # determine state
            cmd = self.get_command(self.current_monitor, zone, self.current_event)
            if zone == self.current_zone:
                sc.add_class('selected')
            else:
                if cmd:
                    sc.add_class('not-selected')
                else:
                    sc.add_class('not-used')
    
    def on_event_changed(self, widget):
        idx = self.event_combo.get_active()
        if idx >= 0:
            self.current_event = self.events[idx]
            self.update_command_display()
    
    def on_command_changed(self, widget):
        """Save immediately when command changes"""
        command = self.command_entry.get_text()
        self.set_command(self.current_monitor, self.current_zone, self.current_event, command)
        self.save_config()
        self.show_conflict_warning()
    
    def on_auto_clear_clicked(self, widget):
        """Auto-clear conflicting wheel event"""
        conflict = self.check_conflict(self.current_event)
        if conflict:
            section = self.get_section_name(self.current_monitor, self.current_zone)
            self.config.remove_option(section, conflict['conflict_event'])
            self.save_config()
            self.show_conflict_warning()
            self.set_status(f"Cleared {conflict['conflict_event']}", error=False)
    
    def on_test_clicked(self, widget):
        """Test command"""
        command = self.command_entry.get_text()
        if not command:
            self.set_status("Enter a command first", error=True)
            return
        try:
            subprocess.Popen(command, shell=True)
            self.set_status(f"Executed!", error=False)
        except Exception as e:
            self.set_status(f"Error: {e}", error=True)
    
    def on_edit_clicked(self, widget):
        """Open config file in default editor"""
        try:
            subprocess.Popen(["xdg-open", str(self.config_file)])
            self.set_status("Opening editor...", error=False)
        except Exception as e:
            self.set_status(f"Error: {e}", error=True)
    
    def on_save_clicked(self, widget):
        """Save config"""
        self.save_config()
    
    def on_restart_clicked(self, widget):
        """Restart daemon"""
        self.set_status("Restarting...", error=False)
        success = self.restart_fittsmon()
        if success:
            self.set_status("‚úì Ready!", error=False)
        else:
            self.set_status("‚úó Error restarting", error=True)
    
    def set_status(self, message, error=False):
        color = "red" if error else "green"
        self.status_label.set_markup(f"<small><span foreground='{color}'>{message}</span></small>")
    
    def run(self):
        print("\n" + "="*50)
        print("  fittsmon")
        print("="*50 + "\n")
        Gtk.main()

if __name__ == "__main__":
    app = FittsmonGUI()
    app.run()
 