#!/usr/bin/env python3
"""
fittsmon Configuration GUI - Simple Edition
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Gdk', '3.0')
from gi.repository import Gtk, Gdk, GLib
import subprocess
import os
import time
from pathlib import Path


class ConfigParser:
    """Custom config parser that preserves case"""
    
    def __init__(self):
        self.data = {}
    
    def read(self, filepath):
        """Read config file preserving case"""
        self.data = {}
        if not filepath.exists():
            return
        
        current_section = None
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                
                if not line or line.startswith('#'):
                    continue
                
                if line.startswith('[') and line.endswith(']'):
                    current_section = line[1:-1]
                    self.data[current_section] = {}
                    continue
                
                if '=' in line and current_section:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    self.data[current_section][key] = value
    
    def write(self, filepath, zones, events, monitors):
        """
        Write config file preserving case
        Writes ALL sections for ALL zones with ALL events (even if empty)
        Order: Primary first, then each secondary monitor
        """
        with open(filepath, 'w') as f:
            f.write("# fittsmon Configuration\n")
            f.write("# Generated by fittsmon GUI\n\n")
            
            # Sort monitors: primary first, then others
            primary_mon = None
            secondary_mons = []
            
            for mon in monitors:
                if mon['primary']:
                    primary_mon = mon
                else:
                    secondary_mons.append(mon)
            
            sorted_monitors = []
            if primary_mon:
                sorted_monitors.append(primary_mon)
            sorted_monitors.extend(secondary_mons)
            
            # Write all monitors in order
            for mon in sorted_monitors:
                mon_name = mon['name']
                
                # Write all zones for this monitor
                for zone in zones:
                    # Create section name
                    if mon['primary']:
                        section_name = zone
                    else:
                        section_name = f"{mon_name}-{zone}"
                    
                    f.write(f"[{section_name}]\n")
                    
                    # Write ALL events (even if empty)
                    for event in events:
                        value = self.data.get(section_name, {}).get(event, "")
                        f.write(f"{event}={value}\n")
                    
                    f.write("\n")
    
    def has_section(self, section):
        return section in self.data
    
    def add_section(self, section):
        if section not in self.data:
            self.data[section] = {}
    
    def get(self, section, option, fallback=""):
        try:
            return self.data[section][option]
        except KeyError:
            return fallback
    
    def set(self, section, option, value):
        if section not in self.data:
            self.data[section] = {}
        self.data[section][option] = value
    
    def remove_option(self, section, option):
        if section in self.data and option in self.data[section]:
            del self.data[section][option]


class HotspotWindow(Gtk.Window):
    """Individual hotspot detail window"""
    
    ZONE_INFO = {
        'TopLeft': {'pos': (0, 0), 'emoji': '‚ÜñÔ∏è'},
        'TopCenter': {'pos': (0.5, 0), 'emoji': '‚¨ÜÔ∏è'},
        'TopRight': {'pos': (1, 0), 'emoji': '‚ÜóÔ∏è'},
        'Left': {'pos': (0, 0.5), 'emoji': '‚¨ÖÔ∏è'},
        'Right': {'pos': (1, 0.5), 'emoji': '‚û°Ô∏è'},
        'BottomLeft': {'pos': (0, 1), 'emoji': '‚ÜôÔ∏è'},
        'BottomCenter': {'pos': (0.5, 1), 'emoji': '‚¨áÔ∏è'},
        'BottomRight': {'pos': (1, 1), 'emoji': '‚ÜòÔ∏è'},
    }
    
    def __init__(self, zone, monitor_name, commands_dict, monitor_geom):
        Gtk.Window.__init__(self, type=Gtk.WindowType.POPUP)
        
        self.zone = zone
        self.monitor_name = monitor_name
        self.commands = commands_dict
        self.monitor_geom = monitor_geom
        
        # Window setup
        self.set_decorated(False)
        self.set_keep_above(True)
        self.set_skip_taskbar_hint(True)
        self.set_skip_pager_hint(True)
        self.set_app_paintable(True)
        self.set_type_hint(Gdk.WindowTypeHint.POPUP_MENU)
        
        # Transparency
        screen = Gdk.Screen.get_default()
        visual = screen.get_rgba_visual()
        if visual:
            self.set_visual(visual)
        self.connect("draw", self.on_draw)
        
        # Content
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        box.set_margin_start(15)
        box.set_margin_end(15)
        
        # Zone header
        header = Gtk.Label()
        header.set_markup(
            f"<big><b>{self.ZONE_INFO[zone]['emoji']} {zone}</b></big>\n"
            f"<small>{monitor_name}</small>"
        )
        header.set_halign(Gtk.Align.CENTER)
        box.pack_start(header, False, False, 0)
        
        # Commands list
        for event, command in commands_dict.items():
            if command.strip():
                cmd_display = command if len(command) < 30 else command[:27] + "..."
                event_label = Gtk.Label()
                event_label.set_markup(f"<small><b>{event}</b>\n{cmd_display}</small>")
                event_label.set_halign(Gtk.Align.START)
                event_label.set_line_wrap(True)
                event_label.set_max_width_chars(35)
                box.pack_start(event_label, False, False, 0)
        
        self.add(box)
        self.set_size_request(300, -1)
        self.show_all()
        self.position_window()
    
    def position_window(self):
        """Position window at zone location on specific monitor"""
        geom = self.monitor_geom
        
        x_pos, y_pos = self.ZONE_INFO[self.zone]['pos']
        
        window_width = 300
        padding = 20
        
        if x_pos == 0:
            x = geom['x'] + padding
        elif x_pos == 0.5:
            x = geom['x'] + (geom['width'] // 2) - (window_width // 2)
        else:
            x = geom['x'] + geom['width'] - window_width - padding
        
        if y_pos == 0:
            y = geom['y'] + padding
        elif y_pos == 0.5:
            y = geom['y'] + (geom['height'] // 2)  # Will be adjusted after getting real height
        else:  # Bottom zones
            y = geom['y'] + geom['height']  # Will be adjusted after getting real height
        
        self.move(int(x), int(y))
        
        # Schedule repositioning after window is fully laid out
        GLib.idle_add(self._reposition_after_layout, geom, x_pos, y_pos)
    
    def _reposition_after_layout(self, geom, x_pos, y_pos):
        """Reposition window after it's been fully drawn"""
        _, window_height = self.get_size()
        x, _ = self.get_position()
        padding = 20
        
        if y_pos == 0:
            y = geom['y'] + padding
        elif y_pos == 0.5:
            y = geom['y'] + (geom['height'] // 2) - (window_height // 2)
        else:  # Bottom zones - anchor to bottom and grow upward
            y = geom['y'] + geom['height'] - window_height - padding
        
        self.move(int(x), int(y))
        return False  # Don't reschedule
    
    def on_draw(self, widget, context):
        """Draw semi-transparent background"""
        import cairo
        context.set_source_rgba(0.1, 0.1, 0.1, 0.88)
        context.paint()
        return False


class MonitorHelper:
    """Helper class to manage monitor information"""
    
    def __init__(self):
        self.monitors = {}
    
    def detect_monitors(self):
        """Detect all monitors and their geometry"""
        self.monitors = {}
        screen = Gdk.Screen.get_default()
        
        for i in range(screen.get_n_monitors()):
            geom = screen.get_monitor_geometry(i)
            monitor_name = screen.get_monitor_plug_name(i)
            
            if not monitor_name:
                monitor_name = f"Monitor-{i}"
            
            self.monitors[monitor_name] = {
                'index': i,
                'x': geom.x,
                'y': geom.y,
                'width': geom.width,
                'height': geom.height
            }
            
            print(f"[MONITOR] {monitor_name}: {geom.x},{geom.y} ({geom.width}x{geom.height})")
        
        return self.monitors
    
    def get_monitor_geom(self, monitor_name):
        """Get geometry for specific monitor"""
        if monitor_name in self.monitors:
            return self.monitors[monitor_name]
        
        if self.monitors:
            return list(self.monitors.values())[0]
        
        return {'x': 0, 'y': 0, 'width': 1920, 'height': 1080}


class ZoneGridWidget(Gtk.Grid):
    """Visual 8-zone grid selector"""
    
    ZONE_INFO = {
        'TopLeft': {'emoji': '‚ÜñÔ∏è', 'pos': (0, 0)},
        'TopCenter': {'emoji': '‚¨ÜÔ∏è', 'pos': (1, 0)},
        'TopRight': {'emoji': '‚ÜóÔ∏è', 'pos': (2, 0)},
        'Left': {'emoji': '‚¨ÖÔ∏è', 'pos': (0, 1)},
        'Right': {'emoji': '‚û°Ô∏è', 'pos': (2, 1)},
        'BottomLeft': {'emoji': '‚ÜôÔ∏è', 'pos': (0, 2)},
        'BottomCenter': {'emoji': '‚¨áÔ∏è', 'pos': (1, 2)},
        'BottomRight': {'emoji': '‚ÜòÔ∏è', 'pos': (2, 2)},
    }
    
    def __init__(self, zones, callback):
        Gtk.Grid.__init__(self)
        self.set_column_spacing(8)
        self.set_row_spacing(8)
        self.set_halign(Gtk.Align.CENTER)
        
        self.zones = zones
        self.callback = callback
        self.buttons = {}
        self.active_zone = zones[0]
        
        # Create 3x3 grid with center empty
        for row in range(3):
            for col in range(3):
                # Skip center (it's empty in the grid)
                if row == 1 and col == 1:
                    continue
                
                # Find zone for this position
                zone = None
                for z, info in self.ZONE_INFO.items():
                    if info['pos'] == (col, row):
                        zone = z
                        break
                
                if zone:
                    btn = Gtk.Button()
                    btn.set_size_request(60, 60)
                    btn.set_label(f"{self.ZONE_INFO[zone]['emoji']}\n{zone.replace('Center', 'C').replace('Left', 'L').replace('Right', 'R')}")
                    btn.set_tooltip_text(zone)
                    btn.connect("clicked", self.on_zone_clicked, zone)
                    
                    self.buttons[zone] = btn
                    self.attach(btn, col, row, 1, 1)
        
        self.update_colors()
        self.show_all()
    
    def on_zone_clicked(self, button, zone):
        """Handle zone button click"""
        self.active_zone = zone
        self.update_colors()
        self.callback(zone)
    
    def update_colors(self):
        """Update button colors based on active zone"""
        for zone, btn in self.buttons.items():
            if zone == self.active_zone:
                # Active = blue
                btn.get_style_context().remove_class("zone-inactive")
                btn.get_style_context().add_class("zone-active")
            else:
                # Inactive = grey/white
                btn.get_style_context().remove_class("zone-active")
                btn.get_style_context().add_class("zone-inactive")
    
    def set_active_zone(self, zone):
        """Set active zone programmatically"""
        if zone in self.buttons:
            self.active_zone = zone
            self.update_colors()


class FittsmonGUI:
    # Only wheel events conflict
    CONFLICT_PAIRS = {
        'WheelUp': 'WheelUpOnce',
        'WheelUpOnce': 'WheelUp',
        'WheelDown': 'WheelDownOnce',
        'WheelDownOnce': 'WheelDown'
    }
    
    def __init__(self):
        self.config_dir = Path.home() / ".config/fittsmon"
        self.config_file = self.config_dir / "fittsmonrc"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.monitors = []
        self.config = ConfigParser()
        self.hotspot_windows = []
        self.monitor_helper = MonitorHelper()
        self.daemon_was_running = False
        
        # Track enter/leave mode state
        self.enter_leave_active_monitor = None
        self.enter_leave_active_zone = None
        self.enter_leave_active_mode = None  # None, 'enter', or 'leave'
        
        # 8 zones in correct order
        self.zones = [
            "TopLeft",
            "TopCenter", 
            "TopRight",
            "Left",
            "Right",
            "BottomLeft",
            "BottomCenter",
            "BottomRight"
        ]
        
        # 9 events
        self.events = [
            "WheelUp",
            "WheelDown",
            "WheelUpOnce",
            "WheelDownOnce",
            "LeftButton",
            "RightButton",
            "MiddleButton",
            "Enter",
            "Leave"
        ]
        
        self.detect_monitors()
        self.load_config()
        
        # Check if daemon was running BEFORE we start the GUI
        self.check_daemon_status()
        
        self.setup_gui()
        self.setup_styles()
        self.update_enter_leave_indicator()
    
    def detect_monitors(self):
        """Detect connected monitors using xrandr"""
        try:
            result = subprocess.run(
                ["xrandr", "--query"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            for line in result.stdout.split('\n'):
                if ' connected' in line:
                    parts = line.split()
                    if len(parts) > 0:
                        monitor_name = parts[0]
                        is_primary = 'primary' in line
                        self.monitors.append({
                            'name': monitor_name,
                            'primary': is_primary
                        })
                        print(f"[DETECT] Monitor: {monitor_name} {'[PRIMARY]' if is_primary else ''}")
        except Exception as e:
            print(f"[ERROR] Monitor detection failed: {e}")
            self.monitors = [{'name': 'default', 'primary': True}]
        
        self.monitor_helper.detect_monitors()
    
    def load_config(self):
        """Load configuration from fittsmonrc"""
        self.config = ConfigParser()
        if self.config_file.exists():
            print(f"[CONFIG] Loading: {self.config_file}")
            self.config.read(self.config_file)
            self.initialize_enter_leave_state()  # Load enter/leave state from config
        else:
            print(f"[CONFIG] File not found - will create on save")
    
    def save_config(self):
        """Save configuration to fittsmonrc"""
        try:
            # Pass zones, events, and monitors to write method
            self.config.write(self.config_file, self.zones, self.events, self.monitors)
            print(f"[CONFIG] Saved: {self.config_file}")
            self.set_status("Saved", error=False)
            return True
        except Exception as e:
            print(f"[ERROR] Failed to save config: {e}")
            self.set_status(f"Error: {e}", error=True)
            return False
    
    def get_section_name(self, monitor, zone):
        """Get config section name for monitor and zone"""
        if monitor == self.monitors[0]['name'] and self.monitors[0]['primary']:
            return zone
        else:
            return f"{monitor}-{zone}"
    
    def get_command(self, monitor, zone, event):
        """Get command for a specific monitor, zone, and event"""
        section = self.get_section_name(monitor, zone)
        return self.config.get(section, event, fallback="")
    
    def check_conflict(self, event):
        """Check if there's a wheel event conflict"""
        if event not in self.CONFLICT_PAIRS:
            return None
        
        conflict_event = self.CONFLICT_PAIRS[event]
        current_cmd = self.get_command(self.current_monitor, self.current_zone, event)
        conflict_cmd = self.get_command(self.current_monitor, self.current_zone, conflict_event)
        
        if current_cmd == "" and conflict_cmd:
            return {
                'event': event,
                'conflict_event': conflict_event,
                'conflict_value': conflict_cmd
            }
        
        return None
    
    def initialize_enter_leave_state(self):
        """Load enter/leave state from config on startup"""
        for section in self.config.data.keys():
            enter_cmd = self.config.get(section, 'Enter', fallback='')
            leave_cmd = self.config.get(section, 'Leave', fallback='')
            
            if enter_cmd:
                # Extract zone and monitor from section
                if '-' in section:
                    parts = section.rsplit('-', 1)
                    monitor_name = parts[0]
                    zone = parts[1]
                else:
                    monitor_name = self.monitors[0]['name']
                    zone = section
                
                self.enter_leave_active_monitor = monitor_name
                self.enter_leave_active_zone = zone
                self.enter_leave_active_mode = 'enter'
                print(f"[ENTER/LEAVE] Loaded: ENTER mode active on {zone}")
                return
            
            if leave_cmd:
                if '-' in section:
                    parts = section.rsplit('-', 1)
                    monitor_name = parts[0]
                    zone = parts[1]
                else:
                    monitor_name = self.monitors[0]['name']
                    zone = section
                
                self.enter_leave_active_monitor = monitor_name
                self.enter_leave_active_zone = zone
                self.enter_leave_active_mode = 'leave'
                print(f"[ENTER/LEAVE] Loaded: LEAVE mode active on {zone}")
                return
    
    def check_enter_leave_conflict(self, monitor, zone, event, command):
        """Check for enter/leave conflicts"""
        # If this event is not Enter or Leave, check if enter/leave is active on this zone
        if event not in ['Enter', 'Leave']:
            if (self.enter_leave_active_monitor == monitor and 
                self.enter_leave_active_zone == zone and 
                self.enter_leave_active_mode):
                return {
                    'type': 'other_action_during_enter_leave',
                    'active_mode': self.enter_leave_active_mode,
                    'zone': zone,
                    'attempted_event': event
                }
        
        # If this event IS Enter or Leave, check for conflicting mode on same zone
        if event in ['Enter', 'Leave']:
            if command:  # Only check if trying to SET a command
                if (self.enter_leave_active_monitor == monitor and 
                    self.enter_leave_active_zone == zone and 
                    self.enter_leave_active_mode and
                    self.enter_leave_active_mode != event.lower()):
                    # Trying to set conflicting mode
                    return {
                        'type': 'conflicting_enter_leave',
                        'active_mode': self.enter_leave_active_mode,
                        'attempted_mode': event.lower(),
                        'zone': zone
                    }
        
        return None
    
    def update_enter_leave_state(self, monitor, zone, event, command):
        """Update enter/leave mode tracking"""
        if event in ['Enter', 'Leave']:
            if command:  # Command is being SET
                self.enter_leave_active_monitor = monitor
                self.enter_leave_active_zone = zone
                self.enter_leave_active_mode = event.lower()
                print(f"[ENTER/LEAVE] {event.upper()} mode activated for {monitor}/{zone}")
            else:  # Command is being CLEARED
                if (self.enter_leave_active_monitor == monitor and 
                    self.enter_leave_active_zone == zone and 
                    self.enter_leave_active_mode == event.lower()):
                    self.enter_leave_active_monitor = None
                    self.enter_leave_active_zone = None
                    self.enter_leave_active_mode = None
                    print(f"[ENTER/LEAVE] {event.upper()} mode deactivated")
    
    def set_command(self, monitor, zone, event, command):
        """Set command for a specific monitor, zone, and event"""
        section = self.get_section_name(monitor, zone)
        
        # Check for enter/leave conflicts FIRST
        el_conflict = self.check_enter_leave_conflict(monitor, zone, event, command)
        if el_conflict:
            return False, el_conflict
        
        if not self.config.has_section(section):
            self.config.add_section(section)
        
        # Auto-clear conflicting wheel events
        if command and event in self.CONFLICT_PAIRS:
            conflict_event = self.CONFLICT_PAIRS[event]
            conflict_cmd = self.config.get(section, conflict_event, fallback="")
            if conflict_cmd:
                print(f"[CONFIG] Auto-clearing: {section}.{conflict_event}")
                self.config.remove_option(section, conflict_event)
        
        # Set the command
        self.config.set(section, event, command)
        
        # Update enter/leave state tracking
        self.update_enter_leave_state(monitor, zone, event, command)
        
        print(f"[CONFIG] Set {section}.{event} = '{command}'")
        return True, None
    
    def is_daemon_running(self):
        """Check if fittsmon daemon is currently running"""
        try:
            result = subprocess.run(
                ["pgrep", "-f", "fittsmon"],
                capture_output=True,
                text=True,
                timeout=2
            )
            is_running = result.returncode == 0
            print(f"[DAEMON] Status check: {'Running' if is_running else 'Not running'}")
            return is_running
        except Exception as e:
            print(f"[ERROR] Failed to check daemon status: {e}")
            return False
    
    def check_daemon_status(self):
        """Check if daemon was running when GUI started"""
        self.daemon_was_running = self.is_daemon_running()
        print(f"[DAEMON] Initial status at startup: {'Running' if self.daemon_was_running else 'Not running'}")
    
    def kill_fittsmon(self):
        """Kill fittsmon process"""
        try:
            subprocess.run(
                ["killall", "fittsmon"],
                capture_output=True,
                text=True,
                timeout=3
            )
            print("[DAEMON] Killed fittsmon")
            time.sleep(0.5)
            return True
        except:
            return False
    
    def start_fittsmon(self):
        """Start fittsmon daemon with all detected monitors"""
        try:
            cmd = ["fittsmon", "--monitor"] + [m['name'] for m in self.monitors]
            print(f"[DAEMON] Starting: {' '.join(cmd)}")
            
            process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,  # discard output
            stderr=subprocess.DEVNULL,
            stdin=subprocess.DEVNULL,
            close_fds=True,
            preexec_fn=os.setsid if hasattr(os, 'setsid') else None
        )
            
            time.sleep(1)
            
            if process.poll() is None:
                print(f"[DAEMON] Started successfully (PID: {process.pid})")
                return True
            else:
                return False
        except Exception as e:
            print(f"[ERROR] Failed to start fittsmon: {e}")
            return False
    
    def restart_fittsmon(self):
        """Restart fittsmon daemon"""
        print("[DAEMON] Restarting fittsmon...")
        self.kill_fittsmon()
        time.sleep(1)
        return self.start_fittsmon()
    
    def show_hotspot_windows(self):
        """Show hotspot windows for all monitors"""
        self.close_hotspot_windows()
        
        for mon_name in [m['name'] for m in self.monitors]:
            mon_geom = self.monitor_helper.get_monitor_geom(mon_name)
            
            for zone in self.zones:
                commands_dict = {}
                for event in self.events:
                    cmd = self.get_command(mon_name, zone, event)
                    if cmd.strip():
                        commands_dict[event] = cmd
                
                if commands_dict:
                    hotspot = HotspotWindow(zone, mon_name, commands_dict, mon_geom)
                    self.hotspot_windows.append(hotspot)
    
    def close_hotspot_windows(self):
        """Close all hotspot windows"""
        for window in self.hotspot_windows:
            window.destroy()
        self.hotspot_windows = []
    
    def setup_styles(self):
        """Setup CSS styles for zone grid"""
        css_provider = Gtk.CssProvider()
        css = """
        .zone-active {
            background-color: #2196F3;
            color: white;
        }
        
        .zone-inactive {
            background-color: #E0E0E0;
            color: #333333;
        }
        
        .zone-active:hover {
            background-color: #1976D2;
        }
        
        .zone-inactive:hover {
            background-color: #BDBDBD;
        }
        """
        css_provider.load_from_data(css.encode())
        context = Gtk.StyleContext()
        context.add_provider_for_screen(
            Gdk.Screen.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )
    
    def setup_gui(self):
        """Setup GTK GUI"""
        self.window = Gtk.Window(type=Gtk.WindowType.TOPLEVEL)
        self.window.set_title("fittsmon")
        self.window.set_default_size(850, 800)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("delete-event", self.on_window_close)
        
        # Set window icon
        try:
            self.window.set_icon_name("input-mouse")
        except:
            pass
        
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
        main_box.set_margin_top(15)
        main_box.set_margin_bottom(15)
        main_box.set_margin_start(15)
        main_box.set_margin_end(15)
        self.window.add(main_box)
        
        # Title
        title = Gtk.Label()
        title.set_markup("<big><b>fittsmon action manager</b></big>\n<small>Screen Corner Hotspots</small>")
        main_box.pack_start(title, False, False, 0)
        
        # Status - BIGGER AND BOLDER
        self.status_label = Gtk.Label()
        self.status_label.set_markup("<span size='large' weight='bold' foreground='green'>Ready</span>")
        self.status_label.set_line_wrap(True)
        self.status_label.set_halign(Gtk.Align.CENTER)
        main_box.pack_start(self.status_label, False, False, 0)
        
        # Enter/Leave mode indicator
        self.enter_leave_label = Gtk.Label()
        self.enter_leave_label.set_markup("<span size='small' foreground='#FF9800'>No enter/leave mode active</span>")
        self.enter_leave_label.set_halign(Gtk.Align.CENTER)
        main_box.pack_start(self.enter_leave_label, False, False, 0)
        
        main_box.pack_start(Gtk.Separator(), False, False, 0)
        
        # Monitor selection
        mon_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        mon_box.pack_start(Gtk.Label(label="Monitor:"), False, False, 0)
        self.monitor_combo = Gtk.ComboBoxText()
        for monitor in self.monitors:
            label = f"{monitor['name']} {'[PRIMARY]' if monitor['primary'] else ''}"
            self.monitor_combo.append_text(label)
        self.monitor_combo.set_active(0)
        self.monitor_combo.connect("changed", self.on_monitor_changed)
        self.current_monitor = self.monitors[0]['name']
        mon_box.pack_start(self.monitor_combo, True, True, 0)
        main_box.pack_start(mon_box, False, False, 0)
        
        # Zone selection with visual grid
        zone_label = Gtk.Label(label="Select Zone:")
        zone_label.set_halign(Gtk.Align.START)
        main_box.pack_start(zone_label, False, False, 0)
        
        self.zone_grid = ZoneGridWidget(self.zones, self.on_zone_grid_clicked)
        main_box.pack_start(self.zone_grid, False, False, 0)
        
        self.current_zone = self.zones[0]
        
        main_box.pack_start(Gtk.Separator(), False, False, 0)
        
        # Event selection
        event_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        event_box.pack_start(Gtk.Label(label="Event:"), False, False, 0)
        self.event_combo = Gtk.ComboBoxText()
        for event in self.events:
            self.event_combo.append_text(event)
        self.event_combo.set_active(0)
        self.event_combo.connect("changed", self.on_event_changed)
        self.current_event = self.events[0]
        event_box.pack_start(self.event_combo, True, True, 0)
        main_box.pack_start(event_box, False, False, 0)
        
        # Event info
        self.info_label = Gtk.Label()
        self.info_label.set_line_wrap(True)
        self.info_label.set_halign(Gtk.Align.START)
        main_box.pack_start(self.info_label, False, False, 0)
        
        # Command input
        cmd_label = Gtk.Label(label="Command:")
        cmd_label.set_halign(Gtk.Align.START)
        main_box.pack_start(cmd_label, False, False, 0)
        self.command_entry = Gtk.Entry()
        self.command_entry.set_placeholder_text("e.g., amixer -D pulse set Master 5%+")
        self.command_entry.connect("changed", self.on_command_changed)
        main_box.pack_start(self.command_entry, False, False, 0)
        
        # Warning box
        self.warning_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.warning_label = Gtk.Label()
        self.warning_label.set_line_wrap(True)
        self.warning_label.set_halign(Gtk.Align.START)
        self.warning_box.pack_start(self.warning_label, False, False, 0)
        
        self.auto_clear_btn = Gtk.Button(label="‚úì Clear Conflict")
        self.auto_clear_btn.connect("clicked", self.on_auto_clear_clicked)
        self.warning_box.pack_start(self.auto_clear_btn, False, False, 0)
        
        main_box.pack_start(self.warning_box, False, False, 0)
        
        self.update_command_display()
        
        # Action buttons
        action_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        test_btn = Gtk.Button(label="üß™ Test")
        test_btn.connect("clicked", self.on_test_clicked)
        action_box.pack_start(test_btn, True, True, 0)
        
        edit_btn = Gtk.Button(label="‚úèÔ∏è  Edit File")
        edit_btn.connect("clicked", self.on_edit_clicked)
        action_box.pack_start(edit_btn, True, True, 0)
        
        main_box.pack_start(action_box, False, False, 0)
        
        # Hotspot toggle button
        hotspot_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        self.hotspot_toggle_btn = Gtk.ToggleButton(label="üëÅÔ∏è  Show Hotspots")
        self.hotspot_toggle_btn.connect("clicked", self.on_hotspot_toggled)
        hotspot_box.pack_start(self.hotspot_toggle_btn, True, True, 0)
        
        main_box.pack_start(hotspot_box, False, False, 0)
        
        # Save & Restart button
        sr_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        save_btn = Gtk.Button(label="üíæ Save")
        save_btn.set_size_request(-1, 40)
        save_btn.get_style_context().add_class("suggested-action")
        save_btn.connect("clicked", self.on_save_clicked)
        sr_box.pack_start(save_btn, True, True, 0)
        
        restart_btn = Gtk.Button(label="‚ü≥ Restart")
        restart_btn.set_size_request(-1, 40)
        restart_btn.get_style_context().add_class("destructive-action")
        restart_btn.connect("clicked", self.on_restart_clicked)
        sr_box.pack_start(restart_btn, True, True, 0)
        
        main_box.pack_start(sr_box, False, False, 0)
        
        self.window.show_all()
    
    def on_window_close(self, widget, event):
        """Handle window close - ensure daemon is still running if it was before"""
        print("[GUI] Window close requested")
        
        # Close hotspot windows first
        self.close_hotspot_windows()
        
        # If daemon was running before we started, make sure it's running now
        if self.daemon_was_running:
            print("[GUI] Daemon was running before GUI started, checking status...")
            if not self.is_daemon_running():
                print("[GUI] Daemon is not running! Restarting...")
                self.set_status("Restarting daemon before closing", error=False)
                # Don't kill, just start it
                if self.start_fittsmon():
                    time.sleep(2)
                    if self.is_daemon_running():
                        print("[GUI] Daemon successfully restarted")
                        self.set_status("Daemon restarted, closing", error=False)
                    else:
                        print("[GUI] Failed to restart daemon!")
                        self.set_status("Warning: Failed to restart daemon", error=True)
                        time.sleep(2)
            else:
                print("[GUI] Daemon is still running, closing cleanly")
        else:
            print("[GUI] Daemon was not running before, not restarting")
        
        # Exit the application
        Gtk.main_quit()
        return False  # Don't prevent the window from closing
    
    def on_zone_grid_clicked(self, zone):
        """Handle zone grid button click"""
        self.current_zone = zone
        self.update_command_display()
    
    def get_event_info(self, event):
        """Get simple event description"""
        info_map = {
            'WheelUp': "Scroll wheel UP",
            'WheelDown': "Scroll wheel DOWN",
            'WheelUpOnce': "Scroll UP once per 2 seconds",
            'WheelDownOnce': "Scroll DOWN once per 2 seconds",
            'LeftButton': "Left mouse button",
            'RightButton': "Right mouse button",
            'MiddleButton': "Middle mouse button",
            'Enter': "Mouse enters corner",
            'Leave': "Mouse leaves corner"
        }
        return info_map.get(event, "")
    
    def update_command_display(self):
        """Update command display"""
        cmd = self.get_command(self.current_monitor, self.current_zone, self.current_event)
        
        self.command_entry.handler_block_by_func(self.on_command_changed)
        self.command_entry.set_text(cmd)
        self.command_entry.handler_unblock_by_func(self.on_command_changed)
        
        self.info_label.set_markup(f"<small>{self.get_event_info(self.current_event)}</small>")
        
        # Update zone grid to show selected zone
        self.zone_grid.set_active_zone(self.current_zone)
        
        self.show_conflict_warning()
        self.update_enter_leave_indicator()
    
    def show_enter_leave_conflict_warning(self, conflict_info):
        """Show warning for enter/leave conflicts"""
        dialog = Gtk.MessageDialog(
            parent=None,
            flags=0,
            message_type=Gtk.MessageType.WARNING,
            buttons=Gtk.ButtonsType.OK,
            text="‚ö†Ô∏è  ACTION BLOCKED: Enter/Leave Mode Active!"
        )
        
        if conflict_info['type'] == 'conflicting_enter_leave':
            msg = (f"Can't set {conflict_info['attempted_mode'].upper()} on {conflict_info['zone']} "
                   f"while {conflict_info['active_mode'].upper()} is active.\n\n"
                   f"Clear {conflict_info['active_mode'].upper()} first or use a different zone.")
        else:  # other_action_during_enter_leave
            msg = (f"Can't set {conflict_info['attempted_event']} while "
                   f"{conflict_info['active_mode'].upper()} is active on {conflict_info['zone']}.\n\n"
                   f"Clear {conflict_info['active_mode'].upper()} first.")
        
        dialog.format_secondary_text(msg)
        dialog.run()
        dialog.destroy()
    
    def update_enter_leave_indicator(self):
        """Update the enter/leave mode indicator in UI"""
        if self.enter_leave_active_mode:
            mode_name = self.enter_leave_active_mode.upper()
            indicator_text = f"üîí {mode_name} mode active on {self.enter_leave_active_zone} ({self.enter_leave_active_monitor})"
            color = '#D32F2F'  # Red
        else:
            indicator_text = "No enter/leave mode active"
            color = '#FF9800'  # Orange
        
        if hasattr(self, 'enter_leave_label'):
            self.enter_leave_label.set_markup(
                f"<span size='small' foreground='{color}'>{indicator_text}</span>"
            )
    
    def show_conflict_warning(self):
        """Show warning only for wheel conflicts"""
        conflict = self.check_conflict(self.current_event)
        
        if conflict:
            msg = (
                f"‚ö†Ô∏è  <b>{conflict['conflict_event']}</b> already set!\n"
                f"Can't use both <b>{conflict['event']}</b> and <b>{conflict['conflict_event']}</b>"
            )
            self.warning_label.set_markup(msg)
            self.warning_box.show_all()
        else:
            self.warning_box.hide()
    
    def on_monitor_changed(self, widget):
        idx = self.monitor_combo.get_active()
        if idx >= 0:
            self.current_monitor = self.monitors[idx]['name']
            self.update_command_display()
    
    def on_event_changed(self, widget):
        idx = self.event_combo.get_active()
        if idx >= 0:
            self.current_event = self.events[idx]
            self.update_command_display()
    
    def on_command_changed(self, widget):
        """Save immediately when command changes"""
        command = self.command_entry.get_text()
        success, conflict = self.set_command(self.current_monitor, self.current_zone, self.current_event, command)
        
        if not success and conflict:
            # Command was rejected
            self.show_enter_leave_conflict_warning(conflict)
            self.set_status("Action blocked: enter/leave mode active", error=True)
            # Revert entry to previous value
            prev_cmd = self.get_command(self.current_monitor, self.current_zone, self.current_event)
            self.command_entry.handler_block_by_func(self.on_command_changed)
            self.command_entry.set_text(prev_cmd)
            self.command_entry.handler_unblock_by_func(self.on_command_changed)
        else:
            self.save_config()
            self.show_conflict_warning()
            self.update_enter_leave_indicator()
            self.set_status("Saved", error=False)
    
    def on_auto_clear_clicked(self, widget):
        """Auto-clear conflicting wheel event"""
        conflict = self.check_conflict(self.current_event)
        if conflict:
            section = self.get_section_name(self.current_monitor, self.current_zone)
            self.config.remove_option(section, conflict['conflict_event'])
            self.save_config()
            self.show_conflict_warning()
            self.set_status(f"Cleared {conflict['conflict_event']}", error=False)
    
    def on_test_clicked(self, widget):
        """Test command"""
        command = self.command_entry.get_text()
        if not command:
            self.set_status("Enter a command first", error=True)
            return
        try:
            subprocess.Popen(command, shell=True)
            self.set_status("Executed", error=False)
        except Exception as e:
            self.set_status(f"Error: {e}", error=True)
    
    def on_edit_clicked(self, widget):
        """Open config file in default editor"""
        try:
            subprocess.Popen(["xdg-open", str(self.config_file)])
            self.set_status("Opening editor", error=False)
        except Exception as e:
            self.set_status(f"Error: {e}", error=True)
    
    def on_hotspot_toggled(self, widget):
        """Toggle hotspot windows for all monitors"""
        if widget.get_active():
            self.show_hotspot_windows()
            self.hotspot_toggle_btn.set_label("üëÅÔ∏è  Hide Hotspots")
            self.set_status("Showing hotspots on all monitors", error=False)
        else:
            self.close_hotspot_windows()
            self.hotspot_toggle_btn.set_label("üëÅÔ∏è  Show Hotspots")
            self.set_status("Hotspots hidden", error=False)
    
    def on_save_clicked(self, widget):
        """Save config"""
        self.save_config()
    
    def on_restart_clicked(self, widget):
        """Restart daemon"""
        self.set_status("Restarting", error=False)
        success = self.restart_fittsmon()
        if success:
            self.set_status("Ready", error=False)
        else:
            self.set_status("Error restarting", error=True)
    
    def set_status(self, message, error=False):
        """Display status message - bigger and bolder"""
        color = "red" if error else "green"
        symbol = "‚úó" if error else "‚úì"
        self.status_label.set_markup(
            f"<span size='large' weight='bold' foreground='{color}'>"
            f"{symbol} {message}"
            f"</span>"
        )
    
    def run(self):
        print("\n" + "="*50)
        print("  fittsmon")
        print("="*50 + "\n")
        Gtk.main()


if __name__ == "__main__":
    app = FittsmonGUI()
    app.run()
